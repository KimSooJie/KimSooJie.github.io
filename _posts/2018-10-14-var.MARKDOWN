---
layout: post
title: "Effective C# :: 지역변수를 선언할때 var를 사용하는것"
date: 2018-10-14 12:44:41 +0900
categories: jekyll update
permalink: /:title
---
###### **빌 와그너 저/김명신 역,Effective C# (3판) 강력한 C#코드를 구현하는 50가지 전략과 기법 [eBook]** 스터디 요약 및 정리

지역변수를 선언하고 초기화할 때는 명시적으로 객체의 타입을 지정하거나, var를 사용해서 컴파일러가 타입을 추론하도록 할 수 있다.
지역변수의 타입 추론은 동적타이핑(런타임시에 객체의 타입을 아는 것)을 말하는 것이 아니라, 컴파일러에게 변수의 타입을 명시적으로 알려주지 않고도 올바른 타입을 추론해 주는 것이다.   

### var를 사용하는 경우

1. 어떤 타입으로 추론될지 짐작해야한다. 그렇기 때문에 변수 타입과 같은 지엽적인 부분보다 변수의 의미에 더 집중 할 수 있다.

2. 개발자가 생각한 타입과 컴파일러가 추론한 타입이 달라서 문제가 되는 경우가 있다. 
   
{% highlight ruby %}
   var f = GetNumber();
   var value = 100 * f / 6;
{% endhighlight %}

   위와같은 경우, value의 타입은 개발자가 의도한 타입이 아닌 GetNumber()의 반환 타입에 의해서 결정된다.
   숫자타입의 경우에 float에서 double 로 확대변환 되거나 long에서 int로의 축소변환과 같은 다양한 형변환이 자동적으로 수행된다. 
   이때 정밀도의 손실이 발생할 수 있는데, 이를 명시적으로 선언하면 변환 과정에서의 위험성을 컴파일러가 사전에 경고한다. 
   그렇기 때문에 value의 타입을 명시적으로 선언하면 문제를 해결할 수 있다.

 3. 컴파일러에게 타입을 추론하도록 맡기는 것이 더 좋은 경우가 있다.

   {% highlight ruby %}
   public IEnumerable<string> FindCostomers(string start)
   {
   	IEnumerable<string> q =
		from c in db.Customers
		select c.ContactName;

	var q2 = q.Where (s => s.StartWith(start));
	return q2;
   }
{% endhighlight %}
  
   이 경우 심각한 성능문제가 발생한다. 변수 q의 타입 때문이다. 데이터베이스에서 쿼리가 수행되는 경우에 LINQ쿼리는 실제로 IQueryable<string>
   타입을 반환한다. 그런데 IQueryable<T> 은 IEnumerable<T>를 상속받기 때문에 위의 코드는 컴파일러 입장에서 문제가 되지 않는다. 그리고 두번째 쿼리
   Where 메서드는 Queryable.Where가 아닌 Enumerable.Where 로 해석된다. 이것은 데이터베이스에서 필요한 데이터만 필터링해서 가져오는 것이 아니라,
   개인 컴퓨터 메모리에 데이터를 모두 불러와서 적재해두고 필터링을 수행하는 것이다.
   그런데 변수 q를 var로 선언한다면, q는 IQueryable <string> 으로 추론된다. 결과는 필터링되고 필요한 데이터만 돌아오게된다. 
   ###### [IEnumerable vs IQueryable] https://www.codeproject.com/Articles/766541/IEnumerable-vs-IQueryable


