---
layout: post
title: "Effective C# :: 캐스트 / is / as"
date: 2018-12-13 12:44:41 +0900
categories: jekyll update
permalink: /:title
---
###### **빌 와그너 저/김명신 역,Effective C# (3판) 강력한 C#코드를 구현하는 50가지 전략과 기법 [eBook]** 스터디 요약 및 정리

형변환을 하는 경우에 캐스팅을 사용하기보다 as 연산자를 사용하는 것이 더 안전하고, 런타임에 더 효율적이다.


{% highlight ruby %}
   public Class MyType
   {
   	   ...
   }

   public Class SecondType
   {
   	   private MyType _my_type;
	   
	   static public implicit operator MyType(SecondType s)
	   {
	   	   return s._my_type;
	   }
   }
{% endhighlight %}

{% highlight ruby %}
   // as 연산자
   object o = new SecondType();
   MyType m = o as MyType;
{% endhighlight %}

{% highlight ruby %}
   // 캐스팅
   object o = new SecondType();
   MyType m = (MyType)o;
{% endhighlight %}

{% highlight ruby %}
   // 이건 가능하지만 이렇게 사용하지는 않는다.
   object o = new SecondType();
   SecondType s = (SecondType)o;

   // (o is SecondType) : true
   // (o is MyType) : false
{% endhighlight %}


예시코드에서 as연산자 / 캐스팅 둘 다 형변환에 실패한다. 컴파일러는 객체 o가 어떤타입으로 선언됐는지만 추적하고, 런타임에는 어떤 타입인지 알 수 없다.
따라서 object 타입이라고 생각하고 MyType으로 형변환 할 수 있는 연산자가  정의되었는지만 확인한다.
그러한 연산자를 정의하지 않았기 때문에 o가 MyType 형식인지 확인하는 코드만 생성한다.

캐스팅을 사용하는 경우에는 o가 어떻게 선언되었는지에 따라서 결과가 다르다.(사용자정의 형변환의 경우)
하지만 as 연산자를 사용하는 경우에는 어떤 타입으로 선언되었든 MyType 이거나 MyType 을 상속한 타입이 아니면 형변환에 실패한다.
