---
layout: post
title: "Effective C# :: 리소스관리(finalizer,IDisposable)"
date: 2019-01-14 12:44:41 +0900
categories: jekyll update
permalink: /:title
---
###### **빌 와그너 저/김명신 역,Effective C# (3판) 강력한 C#코드를 구현하는 50가지 전략과 기법 [eBook]** 스터디 요약 및 정리

.NET 환경에는 garbage collector 가 있어서 메모리누수, dangling pointer, 초기화되지 않은 포인터 등 메모리관리를 해준다. 
그럼에도 불구하고 개발자가 직접 해제작업을 수행하면 더 효율적으로 가비지수집이 이루어질 수 있다.
그 외에 비관리 리소스에 대한 처리를 위해서 .NET은 finalizer 와 IDispoable 인터페이스를 제공한다. 
그러나 finalizer 는 단점이 많기때문에 보통 IDispoable을 사용해서 리소스가 빠르게 해제될 수 있도록 구현하는 것이 좋다. 
C++ 에서처럼 생성자와 소멸자를 사용해서 리소스를 해제하는 것은 C#에서는 제공하지 않는다. 

.NET 가비지수집 과정을 최적화하기 위해서 세대 개념을 사용한다. 가비지 수집이 실행되고 난 이후 객체가 생성되면 0세대가 된다. 
또 한번의 가비지 수집이 실행되고 살아있는 객체는 1세대가 된다. 그 이후에 또 살아있다면 2세대가 된다. 
세대를 구분하는 이유는 비교적 짧은 시간 사용되는 객체와 다른 객체를 구분하기 위함이다.

가비지수집기는 0세대를 우선 처리하고 1세대 2세대 에 대해서는 제한적으로 수집을 수행한다. 
대략 10번에 1번 꼴로 추가적으로 1세대에 대해서 가비지 수집을 하고 100번에 한번 꼴로 2세대에 대한 수집을 한다.

* finalizer

_1. 가비지로 판정된 이후에 곧바로 해제되지 않고, 객체에 대한 참조를 큐에 모아두었다가 일정시간후에 finalizer 가 호출되어 점유하던 메모리를 반납하도록 한다. 
    ( finalizer 가 없는 객체는 메모리로 부터 곧바로 해제된다.)

_2. finalizer 를 가진 객체는 바로 제거되지 않기때문에 1세대 객체가 되고, 이런식으로 오랜 시간 후에 메모리가 해제될 수 있다. 
    따라서 IDisposable 을 통해서 구현하는 것이 좋다.